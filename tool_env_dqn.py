import gym
from stable_baselines3 import DQN  
from stable_baselines3.common.vec_env import DummyVecEnv
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# class ToolEnv(gym.Env):
#     def __init__(self):
#         super(ToolEnv, self).__init__()
#         logger.info("Initializing environment")
#         self.action_space = gym.spaces.Discrete(4)  # 4 tools: nmap, dirb, sqlmap, and wpscan
#         self.observation_space = gym.spaces.Box(low=0, high=1, shape=(1,), dtype=int)  # Just the length of output
#         self.tools = [nmap("127.0.0.1"), dirb("127.0.0.1"), sqlmap("127.0.0.1"), wpscan("127.0.0.1")]
#         self.current_tool_output = 0

#     def reset(self):
#         logger.info("Environment reset")
#         return [0]

#     def step(self, action):
#         logger.info(f"Action chosen: {action}")
#         # Choose tool based on action
#         tool = self.tools[action]
#         result = tool.run()
#         self.current_tool_output = result if result else 0
#         reward = self.current_tool_output
#         done = True  # End the episode after one step
#         return [self.current_tool_output], reward, done, {}

#     def render(self, mode="human"):
#         print(f"Tool Output Length: {self.current_tool_output}")

#     def close(self):
#         logger.info("Environment closed")


# import sys
# sys.path.append("../")
from framework import framework
import numpy as np

class ToolEnv(gym.Env):
    metadata = {'render.modes': ['human']}

    def __init__(self, ip, training=False):
        super(ToolEnv, self).__init__()
        logger.info("Initializing environment")
        self.tools = ['nmap', 'gobuster', 'gospider', 'sqlmap', 'ssh_bruteforce', 'ssh_login', 'wpscan', 'zap', 'ghostcat']
        no_of_tools = len(self.tools)
        self.action_space = gym.spaces.Discrete(no_of_tools)  # 8 tools
        self.observation_space = gym.spaces.Box(low=0, high=1, shape=(1,), dtype=np.uint8)  # Just the length of output
        # self.tools = [nmap("127.0.0.1"), dirb("127.0.0.1"), sqlmap("127.0.0.1"), wpscan("127.0.0.1")]
        self.goal_states = ['sqlmap', 'ssh_login', 'zap', 'ghostcat']
        self.framework = framework(ip, training=training)
        self.tool_action_map = {
            'nmap': self.framework.run_nmap,
            'gobuster': self.framework.run_gobuster,
            'gospider': self.framework.run_gospider,
            'sqlmap': self.framework.run_sqlmap,
            'ssh_bruteforce': self.framework.run_ssh_bruteforce,
            'ssh_login': self.framework.run_ssh_login,
            'wpscan': self.framework.run_wpscan,
            'zap': self.framework.run_zap,
            'ghostcat': self.framework.run_ghostcat,
        }
        self.rewards = [0, 0.001, 0.03]  # for outputs -1, 0, 1
        self.goal_reward = 1.0
        self.current_tool_output = 0
        self.current_tool_chosen = -1

    def reset(self):
        logger.info("Environment reset")
        self.framework.reset_framework()
        self.current_tool_chosen = -1
        self.current_tool_output = 0
        # Return obs
        return np.array([0])  # nmap should always be called first

    def step(self, action):
        logger.info(f"Action chosen: {action}")
        # Choose tool based on action
        tool_called = self.tools[action]
        self.current_tool_chosen = tool_called
        print()
        logger.info(f"Tool called: {tool_called}")

        done = False    # episode is done if goal state is reached
        result = (self.tool_action_map[tool_called])()
        logger.info(f"Return value: {result}")
        self.current_tool_output = result
        reward = self.rewards[result + 1]

        # Handling goal state reward
        if tool_called in self.goal_states and result == 1:
            reward = self.goal_reward
            done = True  # episode is done if goal state is reached
        logger.info(f"Reward provided: {reward}")
        print()

        # Returns (observation, reward, done, info)
        return np.array([self.current_tool_output]), reward, done, {}

    def render(self, mode="human"):
        print(f"Tool Chosen: {self.current_tool_chosen}")
        print(f"Tool Output Length: {self.current_tool_output}")
        print()

    def close(self):
        self.framework.finish()  # Handle framework close
        logger.info("Environment closed")



