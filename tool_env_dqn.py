import gym
from stable_baselines3 import DQN  
from stable_baselines3.common.vec_env import DummyVecEnv
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# class ToolEnv(gym.Env):
#     def __init__(self):
#         super(ToolEnv, self).__init__()
#         logger.info("Initializing environment")
#         self.action_space = gym.spaces.Discrete(4)  # 4 tools: nmap, dirb, sqlmap, and wpscan
#         self.observation_space = gym.spaces.Box(low=0, high=1, shape=(1,), dtype=int)  # Just the length of output
#         self.tools = [nmap("127.0.0.1"), dirb("127.0.0.1"), sqlmap("127.0.0.1"), wpscan("127.0.0.1")]
#         self.current_tool_output = 0

#     def reset(self):
#         logger.info("Environment reset")
#         return [0]

#     def step(self, action):
#         logger.info(f"Action chosen: {action}")
#         # Choose tool based on action
#         tool = self.tools[action]
#         result = tool.run()
#         self.current_tool_output = result if result else 0
#         reward = self.current_tool_output
#         done = True  # End the episode after one step
#         return [self.current_tool_output], reward, done, {}

#     def render(self, mode="human"):
#         print(f"Tool Output Length: {self.current_tool_output}")

#     def close(self):
#         logger.info("Environment closed")


# import sys
# sys.path.append("../")
# from framework import framework
# import numpy as np

# class ToolEnv(gym.Env):
#     metadata = {'render.modes': ['human']}

#     def __init__(self, ip, training=False):
#         super(ToolEnv, self).__init__()
#         logger.info("Initializing environment")
#         self.tools = ['nmap', 'gobuster', 'gospider', 'sqlmap', 'ssh_bruteforce', 'ssh_login', 'wpscan', 'zap', 'ghostcat']
#         no_of_tools = len(self.tools)
#         self.action_space = gym.spaces.Discrete(no_of_tools)  # 8 tools
#         self.observation_space = gym.spaces.Box(low=-1, high=no_of_tools, shape=(1,), dtype=np.int16)  # The current state
#         # self.tools = [nmap("127.0.0.1"), dirb("127.0.0.1"), sqlmap("127.0.0.1"), wpscan("127.0.0.1")]
#         self.goal_states = ['sqlmap', 'ssh_login', 'zap', 'ghostcat']
#         self.framework = framework(ip, training=training)
#         self.tool_action_map = {
#             'nmap': self.framework.run_nmap,
#             'gobuster': self.framework.run_gobuster,
#             'gospider': self.framework.run_gospider,
#             'sqlmap': self.framework.run_sqlmap,
#             'ssh_bruteforce': self.framework.run_ssh_bruteforce,
#             'ssh_login': self.framework.run_ssh_login,
#             'wpscan': self.framework.run_wpscan,
#             'zap': self.framework.run_zap,
#             'ghostcat': self.framework.run_ghostcat,
#         }
#         self.tools_seen = []    # List of tools already run
#         self.rewards = [-0.00001, 0.001, 0.03]  # for outputs -1, 0, 1
#         self.goal_reward = 1.0
#         self.current_tool_output = 0
#         self.current_tool_chosen = -1

#     def reset(self):
#         logger.info("Environment reset")
#         self.framework.reset_framework()
#         self.current_tool_chosen = -1
#         self.current_tool_output = 0
#         self.tools_seen.clear()
#         # Return obs
#         return np.array([-1])  # env reset to -1

#     def step(self, action):
#         print()
#         logger.info(f"Action chosen: {action}")
#         # Choose tool based on action - action is the next tool being choosed
#         tool_chosen = self.tools[action]
        
#         logger.info(f"Tool called: {tool_chosen}")

#         done = False    # episode is done if goal state is reached
#         reward = 0
#         self.current_tool_output = -1

#         if tool_chosen not in self.tools_seen:
#             self.current_tool_chosen = tool_chosen
            
#             result = (self.tool_action_map[tool_chosen])()
#             logger.info(f"Return value: {result}")
#             self.current_tool_output = result
#             reward = self.rewards[result + 1]

#             if result == 1:
#                 self.tools_seen.append(tool_chosen)

#             # Handling goal state reward
#             if tool_chosen in self.goal_states and result == 1:
#                 reward = self.goal_reward
#                 done = True  # episode is done if goal state is reached
#         logger.info(f"Reward provided: {reward}")
#         print()

#         # Returns (observation, reward, done, info)
#         return np.array([action]), reward, done, {}

#     def render(self, mode="human"):
#         print(f"Tool Chosen: {self.current_tool_chosen}")
#         print(f"Tool Output Length: {self.current_tool_output}")
#         print()

#     def close(self):
#         self.framework.finish()  # Handle framework close
#         logger.info("Environment closed")



# REWARDS
# https://stackoverflow.com/questions/63233562/whats-the-principle-to-design-the-reward-function-of-dqn




from framework import framework
import numpy as np

class ToolEnv(gym.Env):
    metadata = {'render.modes': ['human']}

    def __init__(self, ip, training=False):
        super(ToolEnv, self).__init__()
        logger.info("Initializing environment")
        self.tools = ['nmap', 'gobuster', 'gospider', 'sqlmap', 'ssh_bruteforce', 'ssh_login', 'wpscan', 'zap', 'ghostcat']
        self.no_of_tools = len(self.tools)
        self.action_space = gym.spaces.Discrete(self.no_of_tools)  # 8 tools
        self.observation_space = gym.spaces.Dict({
            "agent": gym.spaces.Box(low=0, high=1, shape=(self.no_of_tools,), dtype=np.uint8)  # ob = array of states seen
        })
        self.goal_states = ['sqlmap', 'ssh_login', 'zap', 'ghostcat']
        self.framework = framework(ip, training=training)
        self.tool_action_map = {
            'nmap': self.framework.run_nmap,
            'gobuster': self.framework.run_gobuster,
            'gospider': self.framework.run_gospider,
            'sqlmap': self.framework.run_sqlmap,
            'ssh_bruteforce': self.framework.run_ssh_bruteforce,
            'ssh_login': self.framework.run_ssh_login,
            'wpscan': self.framework.run_wpscan,
            'zap': self.framework.run_zap,
            'ghostcat': self.framework.run_ghostcat,
        }
        self.rewards = [0, 0.00001, 0.03]  # for outputs -1, 0, 1
        # self.rewards = [0.0003, 0.001, 0.003]
        self.goal_reward = 1
        self.penalty = 0
        self.tools_seen_count = 0

    def _get_obs(self):
        return {"agent": self._agent_location}

    def reset(self):
        logger.info("Environment reset")
        super().reset()
        self.framework.reset_framework()

        self._agent_location = [0 for _ in range(self.no_of_tools)]
        self.tools_seen_count = 0
        obs = self._get_obs()

        # Return obs
        return obs  # env reset to [0, ... , 0]

    def step(self, action):
        print()

        # Action is the index of the current tool chosen
        logger.info(f"Action chosen: {action}")
        tool_chosen = self.tools[action]    # The name of the tool chosen
        logger.info(f"Tool called: {tool_chosen}")
        self.tools_seen_count += 1

        done = False    # episode is done if goal state is reached
        reward = 0

        if self._agent_location[action] == 0:
            # Tool not run before
            
            result = (self.tool_action_map[tool_chosen])()
            logger.info(f"Return value: {result}")
            reward = self.rewards[result + 1]

            # Update the obs if able to run
            if result >= 0:
                self._agent_location[action] = 1

            # Handling goal state reward
            if tool_chosen in self.goal_states and result == 1:
                reward = self.goal_reward
                done = True  # episode is done if goal state is reached
            elif sum(self._agent_location) == self.no_of_tools:
                # All tools ran
                done = True
            
        else:
            # Punish for selecting a seen tool
            reward = self.penalty

        reward = reward / pow(self.tools_seen_count, 2)
        logger.info(f"Reward provided: {reward}")

        obs = self._get_obs()
        logger.info(f"Obs: {obs}")
        print()

        # Returns (observation, reward, done, info)
        return obs, reward, done, {}

    def render(self, mode="human"):
        pass

    def close(self):
        self.framework.finish()  # Handle framework close
        logger.info("Environment closed")



